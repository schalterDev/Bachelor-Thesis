\chapter{Konzeption}
\label{Kap4}

\section{Lokale Datenspeicherung}
Moderne Webbrowser stellen viele verschiedene Lösungen zum lokalen Speichern von Daten zu Verfügung. In diesem Kapitel werden diese vorgestellt und miteinander verglichen. Zuletzt wird eine Entscheidung für CROSSLOAD getroffen.

Vergleichskriterien zur lokalen Datenspeicherung ergeben sich aus den Anforderungen. Hinter jedem Kriterium steht in Klammern die Nummer der Anforderung aus \autoref{Kap3:Anforderungen}:
\begin{enumerate}
	\item Ist die \ac{API} asynchron oder nur synchron nutzbar? Eine nur synchron nutzbare Lösung könnte zum einfrieren der Nutzeroberfläche führen (Anforderung 4)
	\item Maximal zulässige Speichermenge (Anforderung 1, 2, und 11)
	\item Mögliche Datentypen. Können Bilder, Audiodateien und Text abgespeichert werden? (Anforderung 1 und 11)
	\item Wie gut wird das Durchsuchen, Filtern und Löschen von Inhalten unterstützt? (Anforderung 7, 8, 9 und 10)
	\item Welche Browser unterstützten diese Funktionalitäten?
\end{enumerate}

\subsection{Web Storage}
Die Web Storage \ac{API} bietet die Möglichkeit Schlüssel / Wert Paare im Browser zu speichern \autocite{mdn-web-storage}. Werte werden immer mit einem Schlüssel gespeichert oder über einen Schlüssel geladen \autocite{mdn-web-storage}.

Alle relevanten Browser implementieren diese \ac{API} \autocite{mdn-web-storage}, es gibt aber auch einige Einschränkungen:
\begin{itemize}
	\item Zugriffe sind nur synchron möglich \autocite{Hajian2019}. Das heißt: wenn große Datenmengen gespeichert oder geladen werden, kann das Browserfenster für eine Zeit lang einfrieren
	\item Als Schlüssel und Werte können jeweils nur Strings gespeichert werden \autocite{Hajian2019}. Sollen JavaScript-Objekte gespeichert werden müssen diese in JSON umgewandelt werden.
	\item Es können maximal 5 \ac{MB} an Daten gespeichert werden \autocite{mdn-web-storage}
\end{itemize}

\bild{architekturen/web-storage}{14cm}{Aufbau der Web Storage \ac{API}}

\autoref{architekturen/web-storage} zeigt die Web Storage \ac{API} mit SessionStorage und LocalStorage. Diese beiden Speicher unterscheiden sich nur darin wie lange Daten gespeichert werden \autocite{Hajian2019} \autocite{mdn-web-storage}. Die Daten vom SessionStorage werden gelöscht sobald die Sitzung auf der Website vorbei ist, das heißt der Browser oder der Tab geschlossen wird \autocite{Hajian2019} \autocite{mdn-web-storage}. Der LocalStorage bleibt über mehrere Sitzungen erhalten und wird nicht automatisch gelöscht \autocite{Hajian2019} \autocite{mdn-web-storage}. In beiden Speichern können Schlüssel-Wert Paare als Text gespeichert werden \autocite{Hajian2019} \autocite{mdn-web-storage}.

\subsection{File System API}
Die File System \ac{API} und FileWrite \ac{API} bieten dem Browser die Möglichkeit Dateien in ein virtuelles Dateisystem abzulegen und von dort wieder zu laden \autocite{Hajian2019} \autocite{storage-for-the-web}. Das \ac{MDN} nennt diese \ac{API} File and Directory Entries \ac{API} \autocite{mdn-file-system}. 

\bild{architekturen/file-system-api}{14cm}{Struktur der File System \ac{API}}

In \autoref{architekturen/file-system-api} ist die Struktur der File System \ac{API} zu sehen. Es gibt Ordner und Dateien. Ein Ordner kann Dateien und Unterordner enthalten. Die \ac{API} erlaubt eine Navigation in den Ordnern, wie zum Beispiel: gehe in den übergeordneten Ordner \autocite{mdn-file-system}. Außerdem lassen sich alle Dateien und Unterordner eines Ordners auflisten \autocite{mdn-file-system}. Dateien können geladen und gespeichert werden \autocite{mdn-file-system}. Diese Dateien und Ordner liegen nur in einem virtuellen Dateisystem und sind in dieser Ordnerstruktur nicht auf der Festplatte des Benutzers wiederzufinden \autocite{mdn-file-system}.

Der Vorteil dieser \ac{API} ist der Umgang mit \acp{blob}, wie zum Beispiel Audiodateien. Diese können leicht gespeichert, geladen und manipuliert werden \autocite{mdn-file-system}. Es können ebenso andere Datentypen wie Strings gespeichert werden \autocite{mdn-file-system}. Außerdem gibt es eine \ac{API} für synchrone und asynchrone Zugriffe \autocite{Hajian2019}. 

Es gibt keinen offiziellen Standard \autocite{mdn-file-system} \autocite{caniuse-filesystem}, deswegen unterstützen noch nicht sehr viele Browser diese \ac{API}. Bisher ist in Chrome und in allen Chromium basierten Browser diese Funktion verfügbar \autocite{caniuse-filesystem}.

\subsection{Web SQL}
Web SQL ist eine \ac{API}, die es erlaubt Daten in einer Datenbank zu speichern und diese Daten mit einer SQL ähnlichen Sprache zu durchsuchen \autocite{w3-web-sql}. Alle Anfragen sind asynchron \autocite{Hajian2019}.

Diese \ac{API} wurde nie von allen Browsern implementiert und ist mittlerweile deprecated, soll also nicht mehr verwendet werden \autocite{Hajian2019}.

Aufgrund der Tatsache, dass Web SQL deprecated ist, wird diese Technologie auch keinen Einsatz bei CROSSLOAD finden und hier nicht weiter erläutert. 

\subsection{IndexedDB}
IndexedDB ist eine key-value NoSQL objekt-orientierte Datenbank zum Speichern von großen und vielen Dateien \autocite{Hajian2019}. Konkret heißt das, dass Objekte mit einem Schlüssel in die Datenbank abgelegt werden können und diese über den angegebenen Schlüssel wieder auffindbar sind. Dabei werden viele unterschiedliche Datentypen (boolean, number, string, date, object, array, regexp, undefined, null, \ac{blob}) \autocite{mdn-indexeddb}, Transaktionen und Indexe zum schnelleren Durchsuchen und Filtern unterstützt \autocite{Sheppard2017}. 

\autoref{architekturen/indexedDB} zeigt den Aufbau von IndexedDB. Es können mehrere Datenbanken erstellt werden und jede Datenbank hat mehrere Object stores \autocite{mdn-indexeddb}. Ein Object store ist mit einer Tabelle in einer relationalen Datenbank vergleichbar. Transaktionen sind innerhalb einer Datenbank über mehrere Object stores möglich \autocite{mdn-indexeddb}. Jeder Object store kann key-value Paare speichern \autocite{Sheppard2017}. Als Werte können JavaScript Objekte, Zahlen, Texte, Bilder, Audiodateien und vieles mehr gespeichert werden \autocite{mdn-indexeddb}. Wenn Werte JavaScript Objekte sind kann auf ein Attribut ein Index gelegt werden \autocite{mdn-indexeddb}. In diesem Beispiel könnte das Attribut \textit{id} oder \textit{titel} oder auch beide indexiert werden.

\bild{architekturen/indexedDB}{14cm}{Architektur der IndexedDB}

IndexedDB kann asynchron verwendet werden \autocite{Hajian2019} \autocite{mdn-indexeddb} und alle relevanten Browser unterstützen die \ac{API} \autocite{mdn-indexeddb-api}. Die maximale Speicherkapazität der Datenbank hängt vom Browser ab und wird in Kapitel~\ref{Kap4:Datenmenge} näher behandelt.

Anfragen an die Datenbank können direkt eine Sortierung oder Suchkriterien enthalten \autocite{mdn-indexeddb}. Dabei ist zu beachten, dass die Textsuche limitiert ist und keine Anfragen zum Finden eines einzelnen Wortes in einem ganzen Text unterstützt \autocite{mdn-indexeddb}. 

Das Programmieren mit der \ac{API} von IndexedDB ist komplex, weil mit Events gearbeitet wird und nicht wie in modernen \acp{API} mit Promises \autocite{Hajian2019}. Deswegen existieren viele Bibliotheken, die eine Verwendung der \ac{API} erleichtern, wie zum Beispiel LocalForage oder Dexie.js \autocite{Hajian2019} \autocite{mdn-indexeddb}.

\subsection{Cache API}
Die Cache \ac{API} bietet die Möglichkeit Netzwerkanfragen zwischenzuspeichern \autocite{mdn-cache-api}. Über Request-Objekte können Response-Objekte gespeichert und geladen werden \autocite{mdn-cache-api}.

\bild{architekturen/cache-api}{14cm}{Aufbau der Cache \ac{API}}

\autoref{architekturen/cache-api} zeigt den Aufbau der Cache \ac{API}: Es können mehrere Caches angelegt werden \autocite{mdn-cache-api}. In einem Cache können mehrere Request-Response Paare gespeichert werden \autocite{mdn-cache-api}. Ein Request-Objekt enthält die URL, die Methode (GET, POST, PUT, ...), einen body und optional noch mehr Parameter \autocite{mdn-request}. Das Response-Objekt ist ähnlich aufgebaut, enthält aber zum Beispiel auch einen Statuscode \autocite{mdn-response}.

Die \ac{API} ist in allen relevanten Browsern verfügbar \autocite{mdn-cache-api}. Oft wird die Cache \ac{API} in Verbindung mit Service Workern verwendet. Die maximale Speicherkapazität des Caches hängt vom Browser ab und wird in Kapitel~\ref{Kap4:Datenmenge} näher erläutert. 

\subsection{Maximale Datenmenge}
\label{Kap4:Datenmenge}
Es gibt keine einheitliche Regelung wie viel Speicher von einer Webseite genutzt werden darf, deswegen hat jeder Browser seine eigenen Regeln \autocite{storage-for-the-web}. 

Chrome und Firefox verfolgen die gleiche Strategie beim vergeben von Speicherplatz: Es gibt einen shared pool, den sich alle Websites teilen \autocite{storage-for-the-web} \autocite{mdn-browser-storage-limit}. Also eine maximale Datenmenge, die der Browser generell speichert. Außerdem gibt es dann noch ein group limit, wobei jede \ac{TLD} eine eigene Gruppe darstellt \autocite{mdn-browser-storage-limit}. Zu einer Gruppe würden also hs-mannheim.de, www.hs-mannheim.de und bib.hs-mannheim.de gehören. Eine weiter Gruppe wäre zum Beispiel uni-mannheim.de Das group limit hängt unter anderem vom shared pool ab. Die genauen Limits sind in \autoref{Kap4:Speicherlimits} angegeben.

Safari erlaubt eine Nutzung von bis zu 1 \ac{GB}, wenn dieses Limit erreicht ist wird der Nutzer gefragt, ob er mehr Speicher erlauben möchte \autocite{storage-for-the-web}. 

\begin{table}
  \renewcommand{\arraystretch}{1.2}
  \centering
  \sffamily
  \begin{footnotesize}
    \begin{tabular}{l l l}
      \toprule
      \textbf{Browser} & \textbf{shared pool} & \textbf{group limit} \\
      \midrule
      \emph{Chrome} & bis zu 60\% der Festplattengröße & 100\% des shared pools \\
      \emph{Firefox} & bis zu 50\% der Festplattengröße & 20\% vom shared pool aber maximal 2 \ac{GB} \\
      \emph{Safari} & nicht bekannt & bis zu 1 \ac{GB}, durch Nutzerbestätigung erweiterbar \\
      \bottomrule
    \end{tabular}
  \end{footnotesize}
  \rmfamily
  \caption{Speicherlimits der Browser}
  \label{Kap4:Speicherlimits}
\end{table}

Die StorageManager \ac{API} kann verwendet werden, um den verfügbaren Speicherplatz abzufragen und den bisher genutzten Speicherplatz abzufragen \autocite{storage-for-the-web}. Diese Angaben müssen nicht genau sein, sondern bieten nur einen Richtwert \autocite{storage-for-the-web}. Diese Funktion wird aber nicht von allen Browsern unterstützt. Im Moment wird die \ac{API} von Firefox und Chrome aber nicht von Safari unterstützt \autocite{mdn-storage-api}.

\subsection{Mögliche Architekturen}
In Tabelle~\ref{Kap4:Datenspeicherung} werden die vorgestellten Möglichkeiten zum Speichern von Daten nach bereits genannten Kriterien verglichen: maximale Datenmenge, mögliche Datentypen, synchron / asynchron, Browsersupport, Aufwand für Suchen und Filtern. Bei fehlenden Feldern in Web SQL wurde nicht weiter recherchiert, weil diese Technologie veraltet ist und nicht mehr verwendet werden soll.

\begin{sidewaystable}[h]
  \renewcommand{\arraystretch}{1.2}
  \centering
  \sffamily
  \begin{footnotesize}
    \begin{tabularx}{1.0\textwidth}{l L L L l l L}
      \toprule
      \textbf{Technologie} & \textbf{Datenmenge} & \textbf{Datentypen} & \textbf{(a)synchron} & \textbf{Browsersupport} & \textbf{Unterstützung für Suchen und Filtern} & \textbf{Anmerkung} \\
      \midrule
      \emph{Web Storage \ac{API}} & max. 5 \ac{MB} & String & nur synchron & alle & nicht vorhanden & \\
      \emph{File System \ac{API}} & max. Speicherkapazität des Browsers & \acp{blob} und weitere & synchron und asynchron & nur Chrome & nicht vorhanden &  \\
      \emph{Web SQL} & - & . & synchron und asynchron & teilweise & vorhanden & veraltet \\
      \emph{IndexedDB} & max. Speicherkapazität des Browsers & einfache Datentypen, Objekte, \acp{blob} & asynchron & alle & vorhanden & \\
      \emph{Cache \ac{API}} & max. Speicherkapazität des Browsers & Request- und Response-Objekte & asynchron & alle & nicht vorhanden & \\
      \bottomrule
    \end{tabularx}
  \end{footnotesize}
  \rmfamily
  \caption{Vergleich der APIs zur lokalen Datenspeicherung}
  \label{Kap4:Datenspeicherung}
\end{sidewaystable}

\clearpage

Web SQL ist deprecated und soll deswegen in CROSSLOAD keine Anwendung finden. Außerdem ist das Speichern von großen Datenmengen dringend erforderlich, weshalb jede Architektur mindestens eine der folgenden Technologien benutzen muss: File System \ac{API}, IndexedDB, Cache \ac{API}.

Es werden nun mögliche Architekturen vorgestellt und miteinander verglichen. 

\subsubsection{Cache API und Web Storage}
Die erste Architektur ist in \autoref{architekturen/architektur-cache-api-web-storage} zu sehen. Es wird die Cache \ac{API} zum Speichern der Audio-Dateien und den Web Storage zum Speichern der Metadaten verwendet. Metadaten sind in diesem Fall alle Information, die zu einem Inhalt gehören abgesehen von der Audio-Datei. Der Web Storage speichert alle ids der bisher favorisierten Inhalte in einem Array. Außerdem hat jede id einen eigenen Eintrag im Web Storage, der die Metadaten enthält. Dieser Ansatz hat den Vorteil, dass schnell überprüft werden kann, ob ein Inhalt favorisiert ist oder nicht. Das Abrufen aller favorisierten Inhalte dauert hingegen lange, weil viele verschiedene Einträge aus dem Web Storage geladen werden müssen. Als alternativen Ansatz könnte man den in \autoref{metadaten-array} beschriebenen umsetzten. Hier werden alle Metadaten in einem einzigen Array gespeichert. Das Laden aller Inhalte ist jetzt schneller. Das Speichern oder Laden eines einzelnen Inhalts dauert dagegen länger, weil immer das gesamte Array geladen oder gespeichert werden muss.

\bild{architekturen/architektur-cache-api-web-storage}{13cm}{Architektur mit Cache API und Web Storage}

\begin{lstlisting}[language=JavaScript,caption={Speichern der Metadaten in einem Array},label={metadaten-array}]
    favoriten: [
    	{
    		id: "id1",
    		titel: "Titel des Inhalts",
    		erstelltAm: "05.06.2020",
    		// weitere Metadaten
    	},
    	{
    		id: "id2",
    		// weitere Metadaten
    	}
    ]
\end{lstlisting}

In \autoref{diagramme/ablauf-cache-api-locale-storage-favorisieren} ist der Ablauf dargestellt wenn ein Nutzer einen Inhalt favorisiert. Sobald der Nutzer einen Inhalt favorisiert werden die Metadaten abgerufen und direkt abgespeichert. Anschließend beginnt der Download der Audio-Datei, welche in der Cache \ac{API} gespeichert wird. Sobald das Herunterladen und Speichern erfolgreich war, wird dies in den Metadaten aktualisiert und der Nutzer benachrichtigt.

\bild{diagramme/ablauf-cache-api-locale-storage-favorisieren}{14cm}{Ablauf für das Favorisieren mit Cache API und Web Storage}

In \autoref{diagramme/ablauf-cache-api-locale-storage-abspielen} wird der Ablauf für das Abspielen eines Inhaltes gezeigt. Damit der Nutzer auf den abzuspielenden Inhalt kommt, lässt er sich alle favorisierten Inhalte anzeigen. Die Metadaten aller Inhalte müssen dementsprechend aus dem Web Storage geladen werden und anschließend angezeigt werden. Der Nutzer wählt einen dieser Inhalte aus. Die Audio-Datei wird nun aus der Cache \ac{API} geladen und abgespielt.

\bild{diagramme/ablauf-cache-api-locale-storage-abspielen}{14cm}{Ablauf für das Abspielen mit Cache API und Web Storage}

Der Vorteil dieser Architektur liegt in der Einfachheit der benutzten \acp{API}. Sowohl die WebStorage \ac{API}, sowie die Cache \ac{API} sind sehr einfach zu verstehen und zu verwenden. Die Nachteile dieser Architektur überwiegen jedoch:

\begin{itemize}
\item Der Zugriff auf den Web Storage ist synchron. Bei vielen Daten kann dies zu längeren Ladezeiten kommen und währenddessen ist das Portal nicht bedienbar. 
\item Durch die Verwendung des Web Storages werden entweder Aktualisierungen der Metadaten oder das Abrufen aller Metadaten ineffizient. 
\item Wenn Inhalte durchsucht oder gefiltert werden müssen, muss dies manuell nach dem Laden aller Metadaten erfolgen.
\end{itemize}

\subsubsection{Cache API und IndexedDB}
Die Architektur bleibt wie in ???, mit dem Unterschied, dass Web Storage durch IndexedDB ersetzt wird. Durch das Ersetzen vom Web Storage durch IndexedDB, fallen viele Nachteile weg. Das Abrufen und Speichern der Metadaten ist nicht synchron, sondern asynchron. Außerdem bietet IndexedDB die Möglichkeit Inhalte zu sortieren und zu filtern, was für CROSSLOAD auch interessant ist. Der Nachteil ist die hinzugekommene Komplexität. 

Die Komplexität kann verringert werden, indem weniger verschiedene \acp{API} eingesetzt werden. Auf IndexedDB soll nicht verzichtet werden, weil diese Vorteile wie Sortierung und Filterung bietet. 

\subsubsection{IndexedDB}
??? zeigt die Architektur nur mit IndexedDB zum Speichern der Daten. Sowohl Metadaten als auch die Audio-Datei werden in der Datenbank abgespeichert. 

\bild{diagramme/ablauf-indexed-db-favorisieren}{13cm}{Ablauf für das Favorisieren mit IndexedDB}

\bild{diagramme/ablauf-indexed-db-abspielen}{13cm}{Ablauf für das Abspielen mit IndexedDB}

Durch das Ersetzen von der Cache \ac{API} durch IndexedDB sind keine Nachteile entstanden. Die Komplexität des Webportals wird nicht erhöht, sondern eher etwas verringert, weil nicht mehr so viele verschiedene \acp{API} verwendet werden.

\subsubsection{Entscheidung}
Zum Speichern der Daten wird allein auf IndexedDB gesetzt. Die zusätzliche Verwendung von der Cache \ac{API} bietet keine weiteren Vorteile und die Verwendung vom Web Storage wird aufgrund der Synchronität abgelehnt.  

\clearpage

\section{Herunterladen der Audiodaten}
Favorisierte Inhalten, sollen für den Offline-Gebrauch heruntergeladen werden. Dafür gibt es verschiedene Möglichkeiten. In diesem Kapitel werden verschiedene Funktionen vorgestellt und miteinander verglichen. 

\subsection{Fetch API}
Die Fetch \ac{API} bietet die Möglichkeit XMLHttpRequests zu verschicken, also Ressourcen von einem Server anzufragen \autocite{Rojas2020}. Verwendet wird die \ac{API} mit Promises, ist also asynchron und bietet eine einfachere Fehlerbehandlung \autocite{Rojas2020} \autocite{mdn-fetch}. 

Diese \ac{API} ist sehr flexibel und kann deswegen sehr gut in service workern oder mit der Cache \ac{API} verwendet werden \autocite{mdn-fetch}. Außerdem unterstützt jeder relevante Browser diese Funktion \autocite{mdn-fetch}. 

Damit eine Netzwerkfrage abgeschickt und empfangen werden kann muss das Browserfenster aber geöffnet sein. Es ist nicht möglich eine Anfrage zu schicken und dann den Browser zu verlassen.

In Angular werden Netzwerkanfragen mit dem HttpService verschickt. Dies ist in diesem Vergleich mit der Fetch \ac{API} gleichzusetzen, weil die gleichen Funktionen vorhanden sind und auch die gleichen Einschränkungen gelten.

\subsection{Background Sync}
Mit Background Sync können Netzwerk Anfragen abgeschickt werden, selbst wenn keine Internetverbindung besteht. Die Anfrage wird gespeichert, bis eine Internetverbindung besteht und dann abgeschickt \autocite{wicg-background-sync}. Diese Funktionalität ist Teil von Service Workern und funktioniert solange ein Service Worker läuft \autocite{wicg-background-sync}. 

Im Moment wird diese Funktion nur von Chrome unterstützt \autocite{caniuse-background-sync}, in Firefox ist sie aber schon in Entwicklung \autocite{status-mozilla-background-sync}.

\subsection{Background Fetch}
Diese \ac{API} bietet die Möglichkeit große Dateien hoch- oder herunterzuladen und zeigt dem Nutzer dabei Informationen über den Fortschritt \autocite{google-background-fetch}. Der Unterschied zu Background Sync liegt auch darin, dass der Download / Upload funktioniert wenn der Browser geschlossen wird und kein Service Worker aktiv ist \autocite{google-background-fetch}. \autoref{screenshots/background-fetch-benachrichtigung-android} zeigt die Fortschrittsanzeige auf einem Android Smartphone. Viele nützliche Funktionen, wie pausieren und fortsetzen des Downloads bei Verbindungsunterbrechungen werden ebenso von Background Fetch übernommen \autocite{google-background-fetch}. 

\bild{screenshots/background-fetch-benachrichtigung-android}{8cm}{Benachrichtigung auf Android bei Benutzung der Background Fetch \ac{API}}

Diese \ac{API} ist im Moment nur in Chrome verfügbar \autocite{google-background-fetch}.

\subsection{Entscheidung}
Die einzige \ac{API}, die von allen relevanten Browsern unterstützt wird, ist die Fetch \ac{API} und wird deswegen auch verwendet. Als Ergänzung kann später Background Sync oder Background Fetch implementiert werden, da diese auch wenn die Website geschlossen ist Inhalte herunterladen können. Background Sync wird wahrscheinlich schneller eine größere Browserunterstützung finden und sollte deswegen bevorzugt werden.

\section{Verbindungsstaus auslesen}
Um eine gute Nutzererfahrung bieten zu können, muss man zu jeder Zeit wissen, ob gerade eine Internetverbindung besteht oder nicht. Außerdem möchte man so schnell wie möglich eine Änderung der Verbindung mitbekommen.

Mit \emph{navigator.onLine} gibt es in allen relevanten Browsern \autocite{caniuse-online} eine Funktion, um zu überprüfen ob eine Internetverbindung besteht oder nicht \autocite{Sheppard2017} \autocite{mdn-online}. Diese \ac{API} arbeitet nicht ganz genau. Wenn eine Verbindung zu einem Netzwerk besteht, in diesem Netzwerk aber kein Internetzugriff möglich ist gibt \emph{navigator.onLine} in manchen Fällen true zurück und signalisiert eine Internetverbindung\autocite{Sheppard2017}. Es kann aber nicht vorkommen, dass der Nutzer offline ist und die \ac{API} true zurück liefert. Dies ist eine zu vernachlässigende Ungenauigkeit, weil dieser Fall nur sehr selten auftritt. 

Wenn eine zuverlässigere Methode benötigt kann einen einfachen Request abschicken. Wenn ein Ergebnis zurück kommt existiert eine Verbindung, wenn ein Fehler geworfen wird, existiert keine Verbindung. 

Des weiteren gibt es auch eine Möglichkeit einen Verbindungsstatuswechsel mitzubekommen. Auf dem <body> Element werden zwei Events gefeuert: \emph{online} wenn der Browser eine Internetverbindung herstellen konnte und \emph{offline} wenn eine bestehende Internetverbindung abbricht \autocite{mdn-online}. Auch hier treffen die Limitierungen von \emph{navigator.onLine} zu.
