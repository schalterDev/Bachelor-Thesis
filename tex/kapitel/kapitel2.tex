\chapter{Grundlagen}
\label{Kap2}
Alle relevanten Grundlagen zum Verständnis dieser Thesis werden in diesem Kapitel erklärt. Dabei geht es um verwendete Begriffe, Technologien sowie Frameworks. Zuletzt wird CROSSLOAD, das zu erweiternde Webportal beschrieben und gezeigt.

\section{Cross-Plattform Entwicklung}
Der Endnutzer hat eine große Auswahl an Geräten, mit denen er ins Internet gehen kann und Anwendungen installieren sowie ausführen kann. Es gibt unterschiedliche Größen an Endgeräten (Smartphones, Tablets, Laptops, PCs) und unterschiedliche Betriebssysteme (Windows, Mac, Android, iOS, ...). Wenn man eine möglichst große Nutzeranzahl erreicht möchte, sollte man seine Anwendung für die meisten Betriebssysteme und Bildschirmgrößen entwickeln. Für jede Plattform eine native Anwendung zu entwickeln, also eine die speziell auf diese Plattform zugeschnitten ist, ist sehr zeitaufwändig und teuer. Deswegen gibt es Cross-Plattform Ansätze. Damit soll erreicht werden, dass nur eine Anwendung entwickelt werden muss und diese dann auf den meisten Plattformen läuft. 

Jedoch hat die Cross-Plattform Entwicklung auch Nachteile: Meistens ist die Bedienung und der Funktionsumfang solcher Anwendungen, im Vergleich zu nativen Anwendungen, schlechter \autocite{cross-plattform}. Das zeigt sich zum Beispiel dadurch, dass es länger dauert bis Inhalte auf dem Bildschirm gezeigt werden \autocite{cross-plattform-energy}. Manche Cross-Plattform Ansätze bieten weniger Funktionalitäten wie zum Beispiel der fehlende Zugriff auf den Kalender oder Bluetooth \autocite{cross-plattform-energy}.

\section{Service Worker}
Service Worker laufen in einem Browser und können JavaScript ausführen \autocite{Sheppard2017}. Sie sind im Hintergrund aktiv, sogar wenn die Webseite geschlossen wurde, haben aber keinen Zugriff aufs \ac{DOM} \autocite{Sheppard2017}. Ein Service Worker ist wie ein Mittler zwischen App und Internet, dabei wird meistens auf die Cache \ac{API} zurückgegriffen \autocite{Sheppard2017}. \autoref{service-worker-funktionsweise} zeigt die Architektur von Service Workern. Wenn die Website eine Netzwerkanfrage schickt, kann der Service Worker diese Anfrage abfangen. Die abgefangene Abfrage kann nun verändert werden, weitergeleitet werden oder mithilfe der Anfrage eine Antwort aus dem Cache geholt werden.

\bild{service-worker-funktionsweise}{10cm}{Service Worker Architektur \autocite{Sheppard2017}}

Service Worker werden sehr oft dafür verwendet, Daten zwischenzuspeichern. Dadurch sind die zwischengespeicherten Daten auch verfügbar, wenn keine Netzwerkverbindung besteht. Doch auch wenn eine Netzwerkverbindung besteht, stehen die Daten schneller zur Verfügung, weil nicht erst auf die Antwort der Netzwerkressource gewartet werden muss. In Angular unterstützen Service Worker deswegen zwei Cache Strategien die hier erklärt werden:

\begin{enumerate}
\item \textit{freshness}: Die zwischengespeicherten Daten werden nur geladen, wenn keine Netzwerkverbindung besteht \autocite{angular-service-worker}. Ansonsten wird auf die Antwort von der Netzwerkanfrage gewartet. Dadurch ist die Anwendung offlinefähig und erhält immer die aktuellsten Daten.
\item \textit{performance}: Wenn zwischengespeicherte Daten zur Verfügung stehen, werden diese bevorzugt geladen und keine Netzwerkanfrage geschickt \autocite{angular-service-worker}. Dadurch wird eine optimale Geschwindigkeit gewährleistet, jedoch sind die Daten nicht immer aktuell. Es ist möglich, ein maximales Alter der zwischengespeicherten Daten festzulegen \autocite{angular-service-worker}. Wenn dieses Alter überschritten wurde, werden die Daten von der Netzwerkressource geladen.
\end{enumerate}

\section{Progressive Web App}
Eine \ac{PWA} ist eine Anwendung, die in modernen Webbrowsern läuft und dem Nutzer dabei eine Erfahrung ähnlich zu bekannten nativen Apps bietet \autocite{Sheppard2017} \autocite{Rojas2020}. Die wichtigsten Eigenschaften und Funktionen dabei sind:

\begin{itemize}
  \item Schnell: Die App startet schnell und bietet schnell die Möglichkeit zur Interaktion \autocite{Hajian2019} \autocite{Sheppard2017}.
  \item Zuverlässig: Auf älteren Geräten funktionsfähig und auch ohne Internetverbindung nutzbar. Außerdem passt sich das Design an verschiedene Bildschirmgrößen an (responsive design) \autocite{Hajian2019} \autocite{Sheppard2017}.
  \item Installierbar: Nach dem Installieren wird ein Icon auf dem Homescreen angezeigt \autocite{Hajian2019} \autocite{Sheppard2017} \autocite{Rojas2020}.
  \item Benachrichtigungen: Der Nutzer kann Benachrichtigungen empfangen, obwohl er die App nicht offen hat \autocite{Hajian2019} \autocite{Sheppard2017}. Eine Messenger-App könnte zum Beispiel eine Benachrichtigung schicken, sobald der Nutzer eine Nachricht bekommt. Dafür ist es nicht erforderlich, dass der Bildschirm an ist oder die App geöffnet ist.
  \item Native-like Funktionen: Zugriff auf Hardware wie zum Beispiel die Kamera ist möglich \autocite{Hajian2019}.
\end{itemize}

Bei der Nutzung bzw. der Entwicklung einer \ac{PWA} entstehen viele Vorteile sowohl für die Entwickler als auch für die Nutzer. Webtechnologien sind weit verbreitet und für jedes Betriebssystem sind moderne Browser verfügbar, wodurch die Anwendung sehr leicht an eine große Nutzergruppe ausgeliefert werden kann \autocite{Rojas2020}. Das Ausliefern an die Nutzer ist zudem sehr einfach, weil diese nur eine URL benötigen \autocite{KHAN2019289} und eine neue Version der App automatisch beim Start der App heruntergeladen wird \autocite{Rojas2020}. Außerdem ist die Entwicklung mit Webtechnologien weit verbreitet, man findet viele Ressourcen und Tools, die bei der Entwicklung helfen \autocite{Rojas2020}. Beim Vergleichen von nativen Apps mit einer \ac{PWA} fällt zudem auf, dass die \ac{PWA} sehr wenig Speicherplatz nach der Installation benötigt \autocite{biorn2017} \autocite{KHAN2019289}. Die Geschwindigkeit einer \ac{PWA} auf Android kann im Vergleich zu anderen Cross-Plattform Ansätzen mithalten oder ist sogar schneller \autocite{biorn2017}.

Eine \ac{PWA} hat nicht nur Vorteile, sondern auch Nachteile. Ein Nachteil ist die Limitierung auf die Funktionen, die der Webbrowser zur Verfügung stellt. Über den Webbrowser ist es zum Beispiel nicht möglich, Sensoren wie den Beschleunigungssensor auszulesen oder direkt auf das Dateisystem zuzugreifen. Zum Tracken von Fitnessaktivitäten ist eine \ac{PWA} auch nicht geeignet, weil diese nur eine kurze Zeit im Hintergrund laufen kann. Wenn die Performance der App eine große Rolle spielt, wie etwa bei Spielen, ist eine \ac{PWA} ebenfalls nicht sehr gut geeignet \autocite{biorn2017}. Hinzu kommt, dass einige Funktionen in den Webbrowsern noch nicht standardisiert sind und / oder noch nicht von allen gängigen Browsern unterstützt werden \autocite{majchrzak2018} \autocite{biorn2017}. Standards werden zum Beispiel von der \ac{W3C} erstellt. Die \ac{W3C} ist eine internationale Gemeinschaft aus Organisationen, Angestellten und Freiwilligen, die gemeinsame Web Standards entwickeln \autocite{w3}. Web Standards sind unter anderem technische Spezifikationen von \acp{API}, Dateiformaten und vielem mehr \autocite{w3-standards}.

Damit aus einer Website eine \ac{PWA} wird, sind mindestens zwei Dinge erforderlich. Erstens wird eine Manifest-Datei benötigt, welche Informationen über das Icon, den Namen und vieles mehr enthält, um die App installieren zu können \autocite{Hajian2019} \autocite{Rojas2020}. Als zweites wird ein Service Worker benötigt, der unter anderem für die Offline-Fähigkeit verantwortlich ist \autocite{Rojas2020}. Der Service Worker speichert alle nötigen Dateien einer Website zwischen und stellt diese zur Verfügung, wenn keine Internetverbindung besteht \autocite{Rojas2020}.

\section{Angular und TypeScript}
Angular ist ein Framework zum Entwickeln von Webanwendungen für alle Plattformen \autocite{angular-io}. Das Framework ist Open Source, getrieben von einer großen Community, wird aber auch von Firmen wie Google weiterentwickelt und genutzt \autocite{angular-io}. Angularanwendungen bestehen unter anderem aus Modulen, Komponenten und Services \autocite{angular-start}. Module fassen mehrere Komponenten zusammen, um diese zu verwalten \autocite{angular-start}. Komponenten sind kleine Bestandteile der Anwendung, die sich vor allem um die Darstellung eines bestimmten Bereichs auf der Seite kümmern \autocite{angular-start} \autocite{Kotaru2020}. In Services liegt die Logik der Anwendung \autocite{angular-start}. Dort werden zum Beispiel Netzwerkanfragen gesendet oder Daten zwischengespeichert. Als Programmiersprache ist TypeScript vorgesehen. 

TypeScript erweitert JavaScript um einige Funktionen wie zum Beispiel Typisierung \autocite{typescript-org}. Die Flexibilität von JavaScript bleibt trotzdem erhalten, weil der Nutzer selbst entscheiden kann, wann er typisieren möchte oder nicht \autocite{typescript-org}. TypeScript kann vor dem Ausliefern in reines JavaScript kompiliert werden und ist somit in allen gängigen Browsern oder auch auf Servern mit Node.js ausführbar \autocite{typescript-org}.

Die Kombination aus Angular und TypeScript bietet eine sehr gute Basis zum Entwickeln von großen, schnellen und skalierbaren Anwendungen \autocite{angular-io}. Durch die statische Typisierung sind zum Beispiel Refactorings mit den vielen verfügbaren Tools schnell und sicher durchzuführen \autocite{typescript-org} \autocite{angular-io}. In der großen Community findet man außerdem auf sehr viele Fragen sofort eine Antwort.

\section{Publish Subscribe Pattern}
In Angular wird häufig mit Observables gearbeitet, um das Publish-Subscribe Pattern, auch Observer-Pattern genannt, umzusetzen. 

\bild{diagramme/publish-subscribe}{12cm}{Publish-Subscribe Pattern UML \autocite{Mezzalira2018}}

\autoref{diagramme/publish-subscribe} zeigt den Aufbau des Publish-Subscribe Patterns. Es gibt ein \textit{Subject}, welches eine Liste an Observern hält \autocite{Mezzalira2018}. Ein Observer kann über \textit{subscribe(observer)} hinzugefügt werden und über \textit{unsubscribe(observer)} auch wieder entfernt werden \autocite{Mezzalira2018}. Sobald beim Subject die Methode \textit{notifiy(notification)} aufgerufen wird, wird bei allen Observern die \textit{update(notification)} Methode aufgerufen \autocite{Mezzalira2018}. Üblicherweise gibt es ein Interface Observer und dazu mindestens eine Implementierung \autocite{Mezzalira2018}.

Dieses Pattern bietet den Vorteil, dass beliebig viele Observer über neue Werte benachrichtigt werden können. 

\section{CROSSLOAD}
CROSSLOAD ist ein Webportal, welches christliche Medien, im Moment hauptsächlich Predigten, zur Verfügung stellt \autocite{crossload-org}. Diese Medien können durchsucht, angehört und heruntergeladen werden. Die Entwicklung befindet sich derzeit in der Beta-Phase (https://beta.crossload.org) und wird vor allem von Ehrenamtlichen vorangetrieben. In \autoref{crossload-mobil-neuste-inhalte} ist die mobile Seite mit den neusten Inhalten auf CROSSLOAD zu sehen. \autoref{crossload-detailansicht} zeigt die Detailansicht, welche sich beim Klick auf eine Predigt öffnet.

Im Frontend wird Angular mit TypeScript zum Entwickeln verwendet. Das Backend besteht aus mehreren Services, die mit unterschiedlichen Sprachen und Frameworks entwickelt werden. \autoref{diagramme/crossload-architektur} zeigt die Architektur. Das Frontend ist in drei Teile aufgeteilt:
\begin{itemize}
\item Components zeigen dem Nutzer Inhalte an. In Components werden keine Berechnungen durchgeführt oder Daten manipuliert.
\item Pages sind für die Datenaufbereitung zuständig, bekommen Daten von Services und geben Daten an Components weiter.
\item Services sind die Schnittstelle zu externen \acp{API}, um Daten abzurufen.
\end{itemize}
Viele Bilder von CROSSLOAD werden von der lizentfreien Fotoplattform Unsplash zur Verfügung gestellt. Für die Suche wird Solr verwendet. Apache Solr ist eine beliebte und schnelle, Open Source, in Java geschriebene Suchmaschine \autocite{solr}. Dateien werden in Amazon S3 abgelegt. Amazon S3 ist ein skalierbarer und schneller Online-Speicher zum Speichern von beliebig vielen Daten, der von Amazon zur Verfügung gestellt wird \autocite{amazon-s3}.

\bild{diagramme/crossload-architektur}{14cm}{Architektur von CROSSLOAD}

Das Webportal erfüllt bereits alle Anforderungen einer \ac{PWA}: Es besitzt eine Manifest-Datei und kann somit auf den Startbildschirm des Smartphones hinzugefügt werden. Statische Inhalte werden mit Hilfe eines Service Workers zwischengespeichert und sind somit auch offline verfügbar. 

\bild{crossload-mobil-neuste-inhalte}{8cm}{CROSSLOAD - Mobile Ansicht der neusten Inhalte}

\bild{crossload-detailansicht}{7cm}{CROSSLOAD - Detailansicht einer Predigt}
