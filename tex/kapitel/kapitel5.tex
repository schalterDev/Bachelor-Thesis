\chapter{Implementierung}
\label{Kap5}

\section{Offline Metadaten}

\subsection{Detailseite}
Im Webportal CROSSLOAD wird bereits ein Service Worker verwendet, der einerseits statische Inhalte zwischenspeicher aber auch dynamische Requests cached. Für dynamische Request wurde bislang die Cache Strategy freshness verwendet. Das heißt, dass der Cache nur verwendet wird wenn der Netzwerk-Request fehlschlägt \autocite{angular-service-worker}. Angular Service Worker unterstützten noch eine zweite Cache Strategie, die immer den Wert aus dem Cache zurück gibt wenn er verfügbar ist \autocite{angular-service-worker}. Die momentane Lösung ist nicht optimal. Sie ermöglicht zwar eine Offlineverfügbarkeit der Daten aber bietet nicht die optimale Geschindigkeit für den Nutzer. In vielen Fällen wird sich der Inhalt im Cache nicht mit der Anwort aus der Netzwerkanfrage unterscheiden, trotzdem muss der Nutzer auf die Antwort vom Netzwerk warten. Eine bessere Lösung ist folgende:

Wenn der Nutzer einen Inhalt möchte, wird direkt im Cache nachgeschaut ob der Inhalt existiert. Wenn er existiert wird er dem Nutzer angezeigt. Gleichzeitig wird eine Netzwerkanfrage geschickt. Sobald die Antwort vom Netzwerk da ist wird die Antwort mit dem Wert im Cache verglichen. Wenn sich die Werte unterscheiden wird der Cache aktualisiert und dem Nutzer die aktuelleren Daten angezeigt. Diese Strategie ist mit Service Workern nicht so einfach zu lösen, weil ein Service Worker nur ein Mittelsmann in einem Request ist. Das heißt er kann nur einen Wert zurückgeben und nicht einen zweiten etwas zeitverzögert. Deswegen wird der Offline Inhalt nicht im Service Worker gecached, sondern in einem Angular-Service.

\bild{diagramme/inhalt-sequenzdiagramm}{14cm}{Sequenzdiagramm für den Abruf der Metadaten eines Inhalts}

In \autoref{diagramme/inhalt-sequenzdiagramm} ist die bereits beschriebene Cache-Strategie beschrieben. Alle Teile in Schwarz, sind bereits vorhanden. Die Teile in Rot sind Ergänzungen im Rahmen dieser Arbeit. Im ContentService werden bereits Subjects und Observables verwendet. Durch das Publish-Subsribe Pattern, das dadurch erzeugt wird ist es möglich mehrere Subscriber (in diesem Fall nur ResultPage) zu benachrichtigen wenn sich ein Inhalt ändert. Darüber ist es auch möglich etwas zeitversetzt einen aktualisierten Inhalt auszuliefern. Der OfflineService verwaltet den Cache, dessen Implementierung wird in \autoref{Kap5:Speicherung} genauer beschrieben. Mit Inhalt sind im diesem Fall immer die Metadaten zu einem Inhalt gemeint, also nicht die Audio-Datei. Diese Daten werden benötigt, um eine Detailseite eines Inhalts anzuzeigen.

\subsection{Suche}
Auf CROSSLOAD ist es möglich Inhalte anhand verschiedener Kriterien zu suchen. Die Suche wird nich gecached, was auch weiterhin so bleiben soll. Die Suchergebnisse können sich oft ändern, zum Beispiel wenn neue Inhalte hinzukommen. Dem Nutzer soll aber trotzdem angezeigt werden, ob ein Inhalt, der in der Suche angezeigt wird, offlien verfügbar bzw. favorisiert ist. Dafür muss für jeden Inhalt von den Suchergebnissen im Offline Speicher geschaut werden, ob ein Inhalt verfügbar ist. Diese Überprüfung kann je nach Anzahl der Inhalte einige Millisekunden dauern. Um die bestmögliche Nutzererfahrung bieten zu können wir eine ähnliche Strategie wie für die Detailseite verwendet:

\bild{diagramme/suche-sequenzdiagramm}{14cm}{Sequenzdiagramm für die Suche nach Inhalten}

In \autoref{diagramme/inhalt-sequenzdiagramm} wird der Ablauf für das Suchen auf CROSSLOAD dargestellt. Alle Teile in Schwarz, sind bereits vorhanden und die Teile in Rot sind Ergänzungen im Rahmen dieser Arbeit. Sobald ein Nutzer Inhalte auf CROSSLOAD sucht wird eine Netzwerkanfrage gesendet. Sobald die Antwort der Anfrage da ist, werden die Inhalte dem Nutzer angezeigt. Gleichzeitig wird für jeden gefunden Inhalt überprüft, ob er offline verfügbar ist. Dieser Status wird dann in das Suchergebnis geschrieben. Sobald alle Inhalte überprüft wurden, werden die aktualisierten Suchergebnisse dem Nutzer angezeigt. Dafür wird wieder das Publish-Subscribe Patern verwendet. 

\section{Grafische Oberfläche}

\section{Lokale Datenspeicherung}
\label{Kap5:Speicherung}
Für die Speicherung von Offlinedaten wurde sich bereits für Indexed DB entschieden. Die Verwendung von Indexed Db ist nicht trivial, weil mit Events gearbeitet wird und nicht wie in moderneren APIs mit Promises \autocite{mdn-indexeddb}. Es gibt aber einige Bibliotheken, die das Arbeiten mit Indexed DB erleichtern. Für diese Arbeit wurde Dexie ausgewählt. Dexie ist ein minimaler Wrapper für Indexed DB, zum Arbeiten mit Promises \autocite{dexie}. Es gibt auch noch andere Bibliotheken wie LocalForage. Dexie wurde ausgewählt, weil mehrere Indexe in der Datenbank unterstützt werden und generell ist die Bibliothek sehr flexibel und trotzdem klein.

Die ganze Logik befindet sich in der Angularanwendung in einem Service. Dieser Service abstrahiert alle Datenzugriffe, sodass falls später notwendig Dexie auch durch eine andere Bibliothek ausgetauscht werden kann. 

Indexed DB besitzt kein Schema wie von relationalen Datenbanken bekannt. Es können beliebige Objekte gespeichert werden, die nicht alle die gleiche Struktur haben. Wenn man diese Objekte aber durchsuchen möchte, sollte man einen Index auf die durchsuchten Eigenschaften legen. Diese Indexe muss man beim Erstellen der Tabellen angeben. Für diese Anwendung werden zwei Tabellen angelegt: \emph{content} und \emph{downloads}. 

Die Tabelle \emph{content} enthält alle Metadaten zu einem Inhalt. Für diese Daten besteht schon ein Datenobjekt, welches in die Datenbank gespeichert wird. Als Index wird vorerst nur die \emph{id} des Inhalts festgelegt. Später wenn auch nach anderen Kriterien gesucht oder gefiltert werden soll, kann ein weiterer Index hinzugefügt werden. 

Die Tabelle \emph{downloads} speichert eine id und die Audiodatei. Es ist nicht möglich zu einer id mehrere Dateien zu speichern. Es wäre auch möglich gewesen die Audiodatei mit dem content-Objekt zu speichern. Dies hätte aber den Nachteil das jedesmal die große Audiodatei aus der Datenbank geladen werden muss wenn die Metadaten zu einem Inhalt geladen werden. In Indexed DB gibt es keine Möglichkeit nur einen Teil eines Objektes zu laden. Durch die Trennung von Metadaten und Audiodaten wird die Anwendung also schneller. Der Nachteil dabei ist, dass dadurch eine Anfrage mehr and die Datenbank gestellt werden muss, um herauszufinden ob eine Audio-Datei für einen Inhalt verfügbar ist.

\section{Herunterladen der Audiodaten}
Auch das Herunterladen der Audiodaten wird in einem Angular-Service umgesetzt. Der Serivce ist dafür zuständig abzufragen welche APIs auf dem aktuellen Gerät unterstützt werden und startet dann den Download. 
